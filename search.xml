<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Collaborative knowledge base embedding for recommender systems</title>
    <url>/2020/09/01/55208/</url>
    <content><![CDATA[<h1 id="文章主要解决什么问题"><a href="#文章主要解决什么问题" class="headerlink" title="文章主要解决什么问题"></a>文章主要解决什么问题</h1><p>利用 知识库 辅助 协同过滤 进行推荐电影和书籍推荐。    </p>
<blockquote>
<p>Tip: 知识库仅包含 item 的信息，无 user 的信息              </p>
<h1 id="解决的思路是什么"><a href="#解决的思路是什么" class="headerlink" title="解决的思路是什么"></a>解决的思路是什么</h1><p>两个步骤</p>
<ul>
<li>知识库的结构化信息使用 TransR 方法嵌入</li>
<li>图像信息、文字信息分别使用 stacked denoising auto-encoders、 stacked convolutional auto-encoders 嵌入</li>
<li>协同学习与训练<h1 id="核心的知识点有哪些"><a href="#核心的知识点有哪些" class="headerlink" title="核心的知识点有哪些"></a>核心的知识点有哪些</h1></li>
<li>TransR embedding method</li>
<li>auto-encoders</li>
<li>SGD tranining<h1 id="模型分块说明"><a href="#模型分块说明" class="headerlink" title="模型分块说明"></a>模型分块说明</h1><img src="/2020/09/01/55208/fig1.png" alt="fig1"><br>模型架构如上图所示。  <h2 id="结构化嵌入"><a href="#结构化嵌入" class="headerlink" title="结构化嵌入"></a>结构化嵌入</h2>使用 <a href="https://zhuanlan.zhihu.com/p/147542008">TransR Embedding</a> 方法，考虑各个 entity 间的 relation，获得知识图谱中 entity 的 vector<br><img src="/2020/09/01/55208/fig2.png" alt="fig2"><h2 id="文字嵌入与图像嵌入"><a href="#文字嵌入与图像嵌入" class="headerlink" title="文字嵌入与图像嵌入"></a>文字嵌入与图像嵌入</h2>文字信息：使用 stacked denoising auto-encoders 获得较优的 vector 表示<br>图像信息：使用 stacked convolutional auto-encoders 获得较优的 vector 表示<br>原始的文字信息/图像信息加一个随机噪音，然后经过 auto-encoders 试图恢复为原有的干净的信息<br><img src="/2020/09/01/55208/fig3.png" alt="fig3"><br><img src="/2020/09/01/55208/fig4.png" alt="fig4"><h2 id="joint-learning"><a href="#joint-learning" class="headerlink" title="joint learning"></a>joint learning</h2>entity 表示为 $\mathbf{e}_{j}=\boldsymbol{\eta}_{j}+\mathbf{v}_{j}+\mathbf{X}_{\frac{L_{t}}{2}, j <em>}+\mathbf{Z}_{\frac{L v}{2}, j </em>}$，分别对应 bias, 结构化嵌入信息，文字嵌入信息，图像嵌入信息。user 对 entity 的偏好表示为 $\mathbf{u}_{i}^{T} \mathbf{e}_{j}$<br>然后使用 SGD 来 maximizing the log-likelihood<script type="math/tex; mode=display">\begin{array}{l}
\mathcal{L}=\sum_{\left(i, j, j^{\prime}\right) \in \mathcal{D}} \ln \sigma\left(\mathbf{u}_{i}^{T} \mathbf{e}_{j}-\mathbf{u}_{i}^{T} \mathbf{e}_{j^{\prime}}\right)-\frac{\lambda_{X}}{2} \sum_{l}\left\|\sigma\left(\mathbf{X}_{l-1} \mathbf{W}_{l}+\mathbf{b}_{l}\right)-\mathbf{X}_{l}\right\|_{2}^{2} \\
+\quad \sum_{\left(v_{h}, r, v_{t}, v_{t^{\prime}}\right) \in \mathcal{S}} \ln \sigma\left(\left\|\mathbf{v}_{h} \mathbf{M}_{r}+\mathbf{r}-\mathbf{v}_{t} \mathbf{M}_{r}\right\|_{2}^{2}-\left\|\mathbf{v}_{h} \mathbf{M}_{r}+\mathbf{r}-\mathbf{v}_{t^{\prime}} \mathbf{M}_{r}\right\|_{2}^{2}\right) \\
-\frac{\lambda_{Z}}{2} \sum_{l \notin\left\{\frac{L_{v}}{2}, \frac{L_{v}}{2}+1\right\}}\left\|\sigma\left(\mathbf{Z}_{l-1} * \mathbf{Q}_{l}+\mathbf{c}_{l}\right)-\mathbf{Z}_{l}\right\|_{2}^{2}-\frac{\lambda_{U}}{2} \sum_{i}\left\|\mathbf{u}_{i}\right\|_{2}^{2} \\
-\frac{\lambda_{Z}}{2} \sum_{l \in\left\{\frac{L_{v}}{2}, \frac{L_{v}}{2}+1\right\}}\left\|\sigma\left(\mathbf{Z}_{l-1} \mathbf{Q}_{l}+\mathbf{c}_{l}\right)-\mathbf{Z}_{l}\right\|_{2}^{2}-\frac{\lambda_{v}}{2} \sum_{v}\|\mathbf{v}\|_{2}^{2} \\
-\frac{1}{2} \sum_{l}\left(\lambda_{W}\left\|\mathbf{W}_{l}\right\|_{2}^{2}+\lambda_{b}\left\|\mathbf{b}_{l}\right\|_{2}^{2}\right)-\frac{1}{2} \sum_{l}\left(\lambda_{Q}\left\|\mathbf{Q}_{l}\right\|_{2}^{2}+\lambda_{c}\left\|\mathbf{c}_{l}\right\|_{2}^{2}\right) \\
-\frac{\lambda_{I}}{2} \sum_{j}\left\|\mathbf{e}_{j}-\mathbf{v}_{j}-\mathbf{X}_{\frac{L_{t}}{2}, j *}-\mathbf{Z}_{\frac{L_{v}}{2}, j *}\right\|_{2}^{2} \\
-\frac{\lambda_{r}}{2} \sum_{r}\|\mathbf{r}\|_{2}^{2}-\frac{\lambda_{M}}{2} \sum_{r}\left\|\mathbf{M}_{r}\right\|_{2}^{2}
\end{array}</script><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1>KG 中无 user 信息<h1 id="有哪些改进的思路"><a href="#有哪些改进的思路" class="headerlink" title="有哪些改进的思路"></a>有哪些改进的思路</h1>KG 中加入 user 信息<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1>好像没有讲 user 的 vector 怎么搞，好像只提到了服从一个正态分布，那么这样做的意义是什么，是否合理？</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>KnowledgeGraph</category>
      </categories>
      <tags>
        <tag>KnowledgeGraph</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1563. 石子游戏 V</title>
    <url>/2020/09/02/31509/</url>
    <content><![CDATA[<p>较为简单的 DP  </p>
<p>类石子合并那样的从小到大的 DP。  </p>
<p>dp[i][j] 表示当前选手在面对 [i, j] 区间时的最优解的情况下的最优分数，显然有：</p>
<script type="math/tex; mode=display">
dp[i][j] = 
\left
\{\begin{array}{lll}
\max_{k} (l_sum + dp[i][k]), & l_sum < r_sum \\
\max_{k} (r_sum + dp[k+1][j]), & l_sum > r_sum \\
\max_{k} ( \max (l_sum + dp[i][k],  r_sum + dp[k+1][j])), & l_sum == r_sum
\end{array}
\right.</script><p>至于 l_sum 和 r_sum 可以用前缀和维护一下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> __ = []()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> mid[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= stoneValue.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        a[i] = a[i<span class="number">-1</span>] + stoneValue[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = stoneValue.<span class="built_in">size</span>();</span><br><span class="line">        init(stoneValue);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= <span class="built_in">size</span>; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">size</span>-len+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> l_sum = a[k] - a[i<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> r_sum = a[j] - a[k];</span><br><span class="line">                    <span class="keyword">if</span> (l_sum &lt; r_sum) &#123;</span><br><span class="line">                        <span class="keyword">long</span> <span class="keyword">long</span> l_val = l_sum+dp[i][k];</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], l_val);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l_sum &gt; r_sum)&#123;</span><br><span class="line">                        <span class="keyword">long</span> <span class="keyword">long</span> r_val = r_sum+dp[k+<span class="number">1</span>][j];</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], r_val);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> <span class="keyword">long</span> l_val = l_sum+dp[i][k];</span><br><span class="line">                        <span class="keyword">long</span> <span class="keyword">long</span> r_val = r_sum+dp[k+<span class="number">1</span>][j];</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], <span class="built_in">max</span>(l_val, r_val));</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="built_in">size</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 486.预测赢家</title>
    <url>/2020/09/01/28669/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很类似于石子合并的 DP 问题<br><code>dp[i][j]</code> 表示目前先手的人在 [i, j] 上能达到的最大分数，那后手的人只能拿到 <code>getsum(i, j) - dp[i][j]</code><br>状态转移方程也很好推，就是拿头和拿尾两种选择。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line">    <span class="keyword">int</span> presum[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> presum[r];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> presum[r]-presum[l<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span> ,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(presum, <span class="number">0</span> ,<span class="keyword">sizeof</span>(presum));</span><br><span class="line">        presum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            presum[i] = nums[i] + presum[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= nums.<span class="built_in">size</span>(); ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i+len<span class="number">-1</span> &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> lef = nums[i] + getsum(i+<span class="number">1</span>, j) - dp[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">int</span> rig = nums[j] + getsum(i, j<span class="number">-1</span>) - dp[i][j<span class="number">-1</span>];</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(lef, rig);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum_score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            sum_score += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>][nums.<span class="built_in">size</span>()<span class="number">-1</span>]*<span class="number">2</span> &gt;= sum_score) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>dp</tag>
      </tags>
  </entry>
</search>
